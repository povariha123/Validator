<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Проверка скрипта команд</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 14px;
    }
    #output {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
      background: #f9f9f9;
    }
    button {
      margin-top: 10px;
      padding: 8px 16px;
      cursor: pointer;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .success {
      color: green;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h1>Проверка команд</h1>

<!-- Кнопка для загрузки списков (можно нажимать повторно, если надо) -->
<button id="loadDataBtn">Загрузить списки из файлов</button>

<p>Введите команды (в формате, как в вашем Python-скрипте):</p>
<textarea id="commandsInput" rows="12" placeholder="Вставьте сюда содержимое, которое раньше хранилось в commands.txt"></textarea>
<br>
<button id="checkBtn">Проверить</button>

<div id="output"></div>

<script>
  /*************************************************************************/
  /*  1) Загрузка допустимых значений из внешних файлов (по ссылкам)       */
  /*************************************************************************/
  // Здесь вместо URL_... подставьте свои ссылки на txt-файлы
  const FILE_LINKS = {
    characters:         "https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/characters.txt",
    points:             "https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/points.txt",
    points_without_seat:"https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/points_without_seat.txt",
    points_with_seat:   "https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/points_with_seat.txt",
    transport:          "https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/transport.txt",
    tools:              "https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/tools.txt",
    emotions:           "https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/emotions.txt",
    car_points:         "https://raw.githubusercontent.com/povariha123/Validator/refs/heads/main/deduplicated_car_points.txt"
  };

  // Глобальные массивы с данными
  let CHARACTERS = [];
  let POINTS = [];
  let POINTS_WITHOUT_SEAT = [];
  let POINTS_WITH_SEAT = [];
  let TRANSPORT = [];
  let TOOLS = [];
  let EMOTIONS = [];
  let CAR_POINTS = [];

  /**
   * Функция загружает текст по ссылке и возвращает массив строк (убирая пустые).
   */
  function loadValues(url) {
    return fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Не удалось загрузить: ${url}, статус: ` + response.status);
        }
        return response.text();
      })
      .then(text => {
        // Разбиваем на строки, убираем пробелы и пустые
        return text
          .split('\n')
          .map(line => line.trim())
          .filter(line => line !== '');
      });
  }

  /**
   * Загрузка всех списков (characters, points и т.п.) параллельно.
   * Возвращает Promise, который завершается, когда все данные загружены.
   */
  function loadAllData() {
    const promises = [];

    promises.push(
      loadValues(FILE_LINKS.characters).then(data => { CHARACTERS = data; })
    );
    promises.push(
      loadValues(FILE_LINKS.points).then(data => { POINTS = data; })
    );
    promises.push(
      loadValues(FILE_LINKS.points_without_seat).then(data => { POINTS_WITHOUT_SEAT = data; })
    );
    promises.push(
      loadValues(FILE_LINKS.points_with_seat).then(data => { POINTS_WITH_SEAT = data; })
    );
    promises.push(
      loadValues(FILE_LINKS.transport).then(data => { TRANSPORT = data; })
    );
    promises.push(
      loadValues(FILE_LINKS.tools).then(data => { TOOLS = data; })
    );
    promises.push(
      loadValues(FILE_LINKS.emotions).then(data => { EMOTIONS = data; })
    );
    promises.push(
      loadValues(FILE_LINKS.car_points).then(data => { CAR_POINTS = data; })
    );

    return Promise.all(promises);
  }

  /*************************************************************************/
  /*  2) Валидация параметров (набор валидаторов)                          */
  /*************************************************************************/
  const VALIDATORS = {
    "character": (value) => CHARACTERS.includes(value),
    "teleport":  (value) => POINTS.includes(value),
    "walk":      (value) => POINTS_WITHOUT_SEAT.includes(value),
    "sit":       (value) => POINTS_WITH_SEAT.includes(value),
    "useTransport": (value) => TRANSPORT.includes(value),
    "camera":    (value) => [...CHARACTERS, ...TRANSPORT].includes(value),
    "lookAt":    (value) => [...CHARACTERS, ...TRANSPORT].includes(value),
    "equipTool": (value) => [...TOOLS, "None"].includes(value),
    "emotion":   (value) => EMOTIONS.includes(value),
    "clone":     (value) => {
      // value должен быть массивом из 2 элементов, где [0] в TOOLS+TRANSPORT, [1] в CAR_POINTS
      // В нашем случае при парсинге clone = { "Val1", "Val2" } мы храним это как массив
      if (!Array.isArray(value) || value.length !== 2) return false;
      const [first, second] = value;
      const validFirst = [...TOOLS, ...TRANSPORT].includes(first);
      const validSecond = CAR_POINTS.includes(second);
      return validFirst && validSecond;
    }
  };

  /*************************************************************************/
  /*  3) Функции для парсинга командных блоков                             */
  /*************************************************************************/

  /**
   * Разбивает строки на блоки { ... }
   * Возвращает массив блоков:
   *  [
   *    {
   *      startLine: номер строки, где встретили '{',
   *      endLine: номер строки, где встретили '}' или '},',
   *      lines: [ {lineNum, text}, ... ] — содержимое блока,
   *      closingText: либо '}' либо '},'
   *    },
   *    ...
   *  ]
   */
  function extractBlocks(lines) {
    const blocks = [];
    let inBlock = false;
    let blockLines = [];
    let blockStartLine = null;

    lines.forEach(({ lineNum, text }) => {
      const stripped = text.trim();
      if (stripped === '{') {
        // Начало блока
        inBlock = true;
        blockStartLine = lineNum;
        blockLines = [];
        return;
      }

      if (stripped === '}' || stripped === '},') {
        // Конец блока
        if (inBlock) {
          blocks.push({
            startLine: blockStartLine,
            endLine: lineNum,
            lines: [...blockLines],
            closingText: stripped
          });
        }
        inBlock = false;
        blockLines = [];
        blockStartLine = null;
        return;
      }

      if (inBlock) {
        blockLines.push({ lineNum, text });
      }
    });

    return blocks;
  }

  /**
   * Проверка синтаксиса одного блока и парсинг его строк в объект параметров.
   * Возвращает { syntaxErrors, parsedParams }.
   *   syntaxErrors: массив объектов { lineNum, type: 'syntax', message }
   *   parsedParams: { param: { value, lineNum }, ... }
   */
  function checkBlockSyntaxAndParse(block, blockIndex, totalBlocks) {
    const syntaxErrors = [];
    const parsedParams = {};

    const closingLineNum = block.endLine;
    const closingText = block.closingText;
    const isLastBlock = (blockIndex === totalBlocks - 1);

    // 1) Проверка, чем заканчивается блок: последний должен быть '}', не последний - '},'
    if (isLastBlock) {
      if (closingText !== '}') {
        syntaxErrors.push({
          lineNum: closingLineNum,
          type: "syntax",
          message: `Последний блок должен завершаться '}', а не '${closingText}'`
        });
      }
    } else {
      if (closingText !== '},') {
        syntaxErrors.push({
          lineNum: closingLineNum,
          type: "syntax",
          message: `Между блоками должна быть запятая: ожидается '},' вместо '${closingText}'`
        });
      }
    }

    // 2) Отберём значимые строки (убираем пустые и комментарии вида '--...')
    const rawParamLines = block.lines.filter(({ text }) => {
      const t = text.trim();
      if (!t) return false;
      if (t.startsWith('--')) return false;
      return true;
    });

    // 3) Проверяем запятые и парсим param=...
    rawParamLines.forEach((item, i) => {
      const { lineNum, text } = item;
      const lineRstrip = text.trimRight();
      const endsWithComma = lineRstrip.endsWith(',');
      const isLastParamLine = (i === rawParamLines.length - 1);

      // Проверка: должен ли быть '='
      if (!lineRstrip.includes('=')) {
        syntaxErrors.push({
          lineNum,
          type: "syntax",
          message: "Строка внутри блока не содержит '=' (ожидается param = value)."
        });
        return;
      }

      // Проверка запятых: все, кроме последней, должны заканчиваться запятой
      if (!isLastParamLine && !endsWithComma) {
        syntaxErrors.push({
          lineNum,
          type: "syntax",
          message: "Каждая строка параметров, кроме последней, должна заканчиваться запятой."
        });
      } else if (isLastParamLine && endsWithComma) {
        syntaxErrors.push({
          lineNum,
          type: "syntax",
          message: "Последняя строка параметров в блоке не должна заканчиваться запятой."
        });
      }

      // Убираем запятую, если была
      const lineNoComma = endsWithComma ? lineRstrip.slice(0, -1).trimRight() : lineRstrip;
      // Регуляркой вынимаем param и value
      const match = lineNoComma.match(/^(\w+)\s*=\s*(.+)$/);
      if (!match) {
        syntaxErrors.push({
          lineNum,
          type: "syntax",
          message: `Не удалось распарсить как 'param = value': ${lineRstrip}`
        });
        return;
      }

      const param = match[1].trim();
      let rawValue = match[2].trim();

      // Специальный случай clone = { ... }
      // Например: clone = { "Val1", "Val2" }
      if (param === 'clone') {
        const cloneMatch = rawValue.match(/^\{(.*)\}$/);
        if (cloneMatch) {
          const inside = cloneMatch[1].trim(); // будет что-то вроде `"Val1", "Val2"`
          // Разобьём по запятым и уберём кавычки
          const items = inside.split(',').map(x => x.trim().replace(/^"(.*)"$/, '$1'));
          parsedParams[param] = { value: items, lineNum };
          return;
        }
      }

      // Обычный случай: строка в кавычках или без
      // Если значение в "..."
      if (rawValue.startsWith('"') && rawValue.endsWith('"')) {
        rawValue = rawValue.slice(1, -1); // убираем кавычки
      }

      parsedParams[param] = { value: rawValue, lineNum };
    });

    return { syntaxErrors, parsedParams };
  }

  /**
   * Проверка значений параметров по валидаторам.
   * Возвращает массив ошибок { lineNum, param, invalidValue }.
   */
  function validateParsedParams(parsedParams) {
    const errors = [];
    for (const [param, { value, lineNum }] of Object.entries(parsedParams)) {
      // Проверяем, есть ли такой параметр в валидаторах
      const validator = VALIDATORS[param];
      if (!validator) {
        // Параметр неизвестен
        errors.push({ lineNum, param, invalidValue: value });
        continue;
      }
      // Проверяем само значение
      const isValid = validator(value);
      if (!isValid) {
        errors.push({ lineNum, param, invalidValue: value });
      }
    }
    return errors;
  }

  /*************************************************************************/
  /*  4) Основная функция проверки (вместо main())                         */
  /*************************************************************************/
  function checkCommands(commandsText) {
    // Разбиваем весь ввод на строки
    const lines = commandsText.split('\n')
      .map((l, i) => ({ lineNum: i + 1, text: l }));

    // 1) Выделяем блоки
    const blocks = extractBlocks(lines);
    if (!blocks.length) {
      return ["Не найдено ни одного блока { ... }."];
    }

    let allErrors = [];
    let allParsedParams = [];

    // 2) Синтаксическая проверка и парсинг
    blocks.forEach((block, i) => {
      const { syntaxErrors, parsedParams } = checkBlockSyntaxAndParse(block, i, blocks.length);
      allErrors = allErrors.concat(syntaxErrors);
      allParsedParams.push(parsedParams);
    });

    // 3) Валидация значений
    allParsedParams.forEach(parsedParams => {
      const paramErrors = validateParsedParams(parsedParams);
      allErrors = allErrors.concat(
        paramErrors.map(e => ({ lineNum: e.lineNum, param: e.param, invalidValue: e.invalidValue }))
      );
    });

    // 4) Формируем итог
    if (!allErrors.length) {
      return ["Ошибок не найдено."];
    } else {
      // Сортируем ошибки по номеру строки
      allErrors.sort((a, b) => a.lineNum - b.lineNum);
      // Преобразуем в человекочитаемый текст
      const resultLines = ["Обнаружены ошибки:"];
      allErrors.forEach(err => {
        if (err.type === "syntax") {
          resultLines.push(`Строка ${err.lineNum}: ${err.message}`);
        } else if (err.param) {
          resultLines.push(
            `Строка ${err.lineNum}: Недопустимое значение параметра '${err.param}' -> '${err.invalidValue}'`
          );
        } else {
          // На всякий случай
          resultLines.push(`Строка ${err.lineNum}: Неизвестная ошибка`);
        }
      });
      return resultLines;
    }
  }

  /*************************************************************************/
  /*  5) Вешаем обработчики на кнопки                                      */
  /*************************************************************************/
  document.getElementById('loadDataBtn').addEventListener('click', () => {
    const outputEl = document.getElementById('output');
    outputEl.textContent = "Загрузка списков...";
    loadAllData()
      .then(() => {
        outputEl.textContent = "Списки успешно загружены!";
        outputEl.className = "success";
      })
      .catch(err => {
        outputEl.textContent = "Ошибка при загрузке списков: " + err.message;
        outputEl.className = "error";
      });
  });

  document.getElementById('checkBtn').addEventListener('click', () => {
    const outputEl = document.getElementById('output');
    const commandsText = document.getElementById('commandsInput').value;

    // Запускаем проверку
    const results = checkCommands(commandsText);

    // Вывод
    if (results.length === 1 && results[0] === "Ошибок не найдено.") {
      outputEl.textContent = results[0];
      outputEl.className = "success";
    } else if (results.length === 1 && results[0].startsWith("Не найдено")) {
      // когда не найдено ни одного блока
      outputEl.textContent = results[0];
      outputEl.className = "";
    } else {
      outputEl.textContent = results.join('\n');
      // если есть слово "Ошибка" - сделаем красным, иначе обычный
      outputEl.className = results.some(line => line.includes("Ошибка") || line.includes("Недопустимое"))
        ? "error"
        : "";
    }
  });
</script>

</body>
</html>
