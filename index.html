<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Command Validator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        textarea {
            width: 100%;
            height: 200px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        .output {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
        }
        .error {
            color: red;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Command Validator</h1>
    <p>Paste your <strong>commands.txt</strong> content below and click "Validate" to check for errors.</p>
    <textarea id="commandsInput" placeholder="Paste your commands.txt content here..."></textarea>
    <button id="validateButton">Validate</button>
    <div id="output" class="output"></div>
</div>

<script>
    async function fetchValues(file) {
        const url = `https://raw.githubusercontent.com/povariha123/Validator/main/${file}`;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to fetch ${file}`);
            const text = await response.text();
            return text.split('\n').map(line => line.trim()).filter(Boolean);
        } catch (error) {
            console.error(error);
            return [];
        }
    }

    async function loadValidators() {
        return {
            character: await fetchValues('characters.txt'),
            teleport: await fetchValues('points.txt'),
            walk: await fetchValues('points_without_seat.txt'),
            sit: await fetchValues('points_with_seat.txt'),
            useTransport: await fetchValues('transport.txt'),
            camera: await fetchValues('characters.txt'),
            equipTool: (await fetchValues('tools.txt')).concat(["None"]),
            emotion: await fetchValues('emotions.txt'),
            clone: async value => {
                const tools = await fetchValues('tools.txt');
                const transport = await fetchValues('transport.txt');
                const points = await fetchValues('points.txt');
                return Array.isArray(value) &&
                    value.length === 2 &&
                    (tools.concat(transport).includes(value[0])) &&
                    points.includes(value[1]);
            }
        };
    }

    async function validateCommand(command, validators) {
        const errors = [];
        for (const [key, value] of Object.entries(command)) {
            const validator = validators[key];
            if (validator) {
                const isValid = typeof validator === 'function'
                    ? await validator(value)
                    : validator.includes(value);
                if (!isValid) {
                    errors.push(`Invalid value for '${key}': '${JSON.stringify(value)}'`);
                }
            }
        }
        return errors;
    }

    async function parseCommands(input) {
        try {
            let content = input;
            content = content.replace(/\{\s*clone\s*=\s*\{(.*?)\}\s*\},/g, (m, p1) => `clone = [{${p1.trim()}}],`);
            content = content.replace(/clone\s*=\s*{([^}]+)}/g, (m, p1) => `clone = [${p1.trim()}]`);
            content = content.replace(/(\w+)\s*=\s*/g, '"$1": ');
            content = content.replace(/,(\s*})/g, '$1');
            content = `[${content}]`;
            return JSON.parse(content);
        } catch (error) {
            throw new Error(`Error parsing commands: ${error.message}`);
        }
    }

    document.getElementById('validateButton').addEventListener('click', async () => {
        const outputElement = document.getElementById('output');
        const commandsInput = document.getElementById('commandsInput').value;

        try {
            const validators = await loadValidators();
            const commands = await parseCommands(commandsInput);

            const allErrors = [];
            for (let i = 0; i < commands.length; i++) {
                const commandErrors = await validateCommand(commands[i], validators);
                if (commandErrors.length > 0) {
                    allErrors.push(`Line ${i + 1}:\n` + commandErrors.join('\n'));
                }
            }

            outputElement.innerHTML = allErrors.length
                ? allErrors.map(error => `<p class="error">${error}</p>`).join('')
                : '<p>No errors found!</p>';
        } catch (error) {
            outputElement.innerHTML = `<p class="error">${error.message}</p>`;
        }
    });
</script>
</body>
</html>
